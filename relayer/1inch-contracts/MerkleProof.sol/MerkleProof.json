{"abi":[{"type":"error","name":"MerkleProofInvalidMultiproof","inputs":[]}],"bytecode":{"object":"0x6080806040523460175760399081601c823930815050f35b5f80fdfe5f80fdfea2646970667358221220a71ada22d270ea8de55948301986a0632088adcf919dcb0977b41a30c2182c1b64736f6c63430008170033","sourceMap":"841:8421:44:-:0;;;;;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x5f80fdfea2646970667358221220a71ada22d270ea8de55948301986a0632088adcf919dcb0977b41a30c2182c1b64736f6c63430008170033","sourceMap":"841:8421:44:-:0;;","linkReferences":{}},"methodIdentifiers":{},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MerkleProofInvalidMultiproof\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"These functions deal with verification of Merkle Tree proofs. The tree and the proofs can be generated using our https://github.com/OpenZeppelin/merkle-tree[JavaScript library]. You will find a quickstart guide in the readme. WARNING: You should avoid using leaf values that are 64 bytes long prior to hashing, or use a hash function other than keccak256 for hashing leaves. This is because the concatenation of a sorted pair of internal nodes in the Merkle tree could be reinterpreted as a leaf value. OpenZeppelin's JavaScript library generates Merkle trees that are safe against this attack out of the box.\",\"errors\":{\"MerkleProofInvalidMultiproof()\":[{\"details\":\"The multiproof provided is not valid.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\":\"MerkleProof\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":@1inch/limit-order-protocol-contract/=contracts/lib/cross-chain-swap/lib/limit-order-protocol/\",\":@1inch/limit-order-settlement/=contracts/lib/cross-chain-swap/lib/limit-order-settlement/\",\":@1inch/solidity-utils/=contracts/lib/cross-chain-swap/lib/solidity-utils/\",\":@openzeppelin/contracts/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/\",\":cross-chain-swap/=contracts/lib/cross-chain-swap/contracts/\",\":ds-test/=contracts/lib/cross-chain-swap/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=contracts/lib/forge-std/src/\",\":limit-order-protocol/=contracts/lib/cross-chain-swap/lib/limit-order-protocol/\",\":limit-order-settlement/=contracts/lib/cross-chain-swap/lib/limit-order-settlement/\",\":murky/=contracts/lib/cross-chain-swap/lib/murky/\",\":openzeppelin-contracts/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/\",\":solidity-utils/=contracts/lib/cross-chain-swap/lib/solidity-utils/\"],\"viaIR\":true},\"sources\":{\"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/Hashes.sol\":{\"keccak256\":\"0x89c4d3509df3e1387752bf07f04bdf967ddb424d8917808bc9e6e4bc7995db0e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2909c1aa5cc0ef4288e88c361fc114838aeb2c9396f83886ab9c52b39baf602f\",\"dweb:/ipfs/QmS246CQ6JN1dH3khhZvURLFEgfJ1DiV7J1VYxisfqLVnm\"]},\"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\":{\"keccak256\":\"0x2fe0f666490bd88fa762c0c49cbba17e847e45cf259d744d6797636392beee41\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1ad7a55cdd08f0c336167e50e2fd172142de995409a81ffc0602792262f2e86c\",\"dweb:/ipfs/QmY7g2r17jJ6ZGoJ3DzSa7abQzvUXJATGy4sd8SEPt7oA3\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.23+commit.f704f362"},"language":"Solidity","output":{"abi":[{"inputs":[],"type":"error","name":"MerkleProofInvalidMultiproof"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@1inch/limit-order-protocol-contract/=contracts/lib/cross-chain-swap/lib/limit-order-protocol/","@1inch/limit-order-settlement/=contracts/lib/cross-chain-swap/lib/limit-order-settlement/","@1inch/solidity-utils/=contracts/lib/cross-chain-swap/lib/solidity-utils/","@openzeppelin/contracts/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/","cross-chain-swap/=contracts/lib/cross-chain-swap/contracts/","ds-test/=contracts/lib/cross-chain-swap/lib/forge-std/lib/ds-test/src/","erc4626-tests/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=contracts/lib/forge-std/src/","limit-order-protocol/=contracts/lib/cross-chain-swap/lib/limit-order-protocol/","limit-order-settlement/=contracts/lib/cross-chain-swap/lib/limit-order-settlement/","murky/=contracts/lib/cross-chain-swap/lib/murky/","openzeppelin-contracts/=contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/","solidity-utils/=contracts/lib/cross-chain-swap/lib/solidity-utils/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol":"MerkleProof"},"evmVersion":"shanghai","libraries":{},"viaIR":true},"sources":{"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/Hashes.sol":{"keccak256":"0x89c4d3509df3e1387752bf07f04bdf967ddb424d8917808bc9e6e4bc7995db0e","urls":["bzz-raw://2909c1aa5cc0ef4288e88c361fc114838aeb2c9396f83886ab9c52b39baf602f","dweb:/ipfs/QmS246CQ6JN1dH3khhZvURLFEgfJ1DiV7J1VYxisfqLVnm"],"license":"MIT"},"contracts/lib/cross-chain-swap/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol":{"keccak256":"0x2fe0f666490bd88fa762c0c49cbba17e847e45cf259d744d6797636392beee41","urls":["bzz-raw://1ad7a55cdd08f0c336167e50e2fd172142de995409a81ffc0602792262f2e86c","dweb:/ipfs/QmY7g2r17jJ6ZGoJ3DzSa7abQzvUXJATGy4sd8SEPt7oA3"],"license":"MIT"}},"version":1},"storageLayout":{"storage":[],"types":{}},"id":44}